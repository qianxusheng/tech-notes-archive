## 根据频率排序

### 计算机网络

- **TCP / UDP**
- **三次握手**
  - 第三次的目的是让客户端确认服务端收到了自己的 ACK，确保双方都具备收发能力。
- **四次挥手**
  - 第四次的目的是确保服务端把自己剩余的数据发送完毕，再主动关闭连接。
  - `TIME_WAIT` 的目的：
    - 防止“已失效的连接数据包”混入下一次连接；
    - 确保最后的 ACK 能让服务端收到。

---

### 数据结构

#### 哈希表原理

- 结构：数组 + 链表（拉链法）+ 红黑树（JDK1.8优化）
- 哈希冲突和解决方案：
  - **开放地址法**
    - 线性探测法：容易导致元素聚集
    - 二次探测法：使用二次函数间隔减少聚集
    - 双重哈希：使用另一个哈希函数避免一次探测失败
  - **拉链法**：链表或红黑树（冲突元素挂链）

#### 哈希扩容

- 每次扩容两倍
- 插入 n 个元素，总成本约为：1 + 2 + 4 + 8 + ... ≈ n
- 插入操作的均摊时间复杂度仍为常数级 O(1)

#### B 树与 B+ 树
- **前身**
  - BST 二叉搜索树
  - 红黑树 自平衡二叉搜索树，常用于实现Treemap（map：基于键值对的数据结构，treemap有序，因为底层用了红黑树）
  - 2-3 Tree 每个节点可以有2个key和3个children；自平衡搜索树
- **B 树**
  - 多路平衡查找树，数据分布在所有节点；可以有更多key；
- **B+ 树**
  - 所有数据只存储在叶子节点
  - 非叶子节点只存索引
  - 叶子节点通过双向链表连接
  - 支持快速范围查询
  - 常用于磁盘/数据库系统

#### 哈希表的并发问题

- 高并发下容易读写冲突
- 各语言对并发哈希表的实现：
  - **Java**
    - `HashMap` 非线程安全
    - `Collections.synchronizedMap()`：外部加锁，多个线程竞争时，其他线程需要等待锁释放，性能开销较大
    - `ConcurrentHashMap`：
      - JDK7：分段锁
      - JDK8+：CAS + 链表/红黑树   --重要优化，可以深入学习
  - **C++**
    - `std::unordered_map` 非线程安全
    - 使用 `mutex` 加锁或第三方并发容器库实现安全访问
    
---

### 算法
